# 스프링 핵심 기술의 응용
### SQL과 DAO의 분리
SQL 변경이 필요한 상황이 발생하면 SQL을 담고 있는 DAO 코드가 수정될 수밖에 없다.
#### XML 설정을 이용한 분리
스프링은 설정을 이용해 빈에 값을 주입해줄 수 있다. SQL은 문자열로 되어 있으니 설정파일에 프로퍼티 값으로 정의해서 DAO에 주입해줄 수 있다. 이렇게 하면 설정파일에 있는 SQL을 코드와는 독립적으로 수정할 수가 있다.
##### 개별 SQL 프로퍼티 방식
* add() 메소드를 위한 SQL 필드
```
public class UserDaoJdbc implements UserDao {
  private String sqlAdd;
  
  public void setSqlAdd(String sqlAdd) {
    this.sqlAdd = sqlAdd;
  }
}
```
* 주입받은 SQL 사용
```
public void add(User user) {
  this.jdbcTemplate.update(
    this.sqlAdd, // "insert into users..."를 제거하고 외부에서 주입받은 SQL을 사용하게 한다.
    user.getId(), user.getNamq(), user.getPassword(), user.getEmail(),
    user.getLevel().intValue(), user.getLogin(), user.getRecommend());
  )
}
```
* 설정파일에 넣은 SQL 문장
```
<bean id="userDao" class="springbook.user.dao.UserDaoJdbc">
  <property name="dataSource ref="dataSource" />
  <property name="sqlAdd" value="insert into users(id, name, password, email, level, login, recommend)
     values(?,?,?,?,?,?,?)" />
  ...
```
> 스프링에서는 스트링 값을 외부에서 DI 해서 사용할 수 있기 때문에 손쉽게 SQL을 분리하는 데 성공했다. 하지만 이 방법은 매번 새로운 SQL이 필요할 때마다 프로퍼티를 추가하고 DI를 위한 변수와 수정자 메소드도 만들어줘야 하기 때문에 불편하다.

##### SQL 맵 프로퍼티 방식
SQL을 하나의 컬렉션으로 담아두는 방법
* 맵 타입의 SQL 정보 프로퍼티
```
public class UserDaoJdbc implements UserDao {
  ...
  private Map<String, String> sqlMap;
  
  public void setSqlMap(Map<String, String> sqlMap) {
    this.sqlMap = sqlMap;
  }
}
```
* sqlMap을 사용하도록 수정한 add()
```
public void add(User user) {
  this.jdbcTemplate.update(
    this.sqlMap.get("add"), // 프로퍼티로 제공받은 맵으로부터 키를 이용해서 필요한 SQL을 가져온다.
    user.getId(), user.getNamq(), user.getPassword(), user.getEmail(),
    user.getLevel().intValue(), user.getLogin(), user.getRecommend());
  )
}
```
* 맵을 이용한 SQL 설정
```
<bean id="userDao" class="springbook.user.dao.UserDaoJdbc">
  <property name="dataSource ref="dataSource" />
  <property name="sqlMap">
    <map>
      <entry key="add" value="insert into users(id, name, password, email, level, login, recommend)
        values(?,?,?,?,?,?,?)" />
      <entry key="get" value="select * from users where id = ?" />
      <entry key="getAll" value="select * from users order by id" />
      <entry key="deleteAll" value="delete from users" />
      <entry key="getCount" value="select count(*) from users" />
      <entry key="update" value="update users set name = ?, password = ?,
        email = ?, level = ?, login = ?, recommend = ? where id = ?" />
    </map>
  </property>
</bean>
```
> 맵으로 만들어두면 새로운 SQL이 필요할 때 설정에 entry만 추가해주면 되니 모든 SQL을 일일이 프로퍼티로 등록하는 방법에 비해 작업량도 적고 코드도 간단해서 좋다. 대신 메소드에서 SQL을 가져올 때 문자열로 된 키 값을 사용하기 때문에 오타와 같은 실수가 있어도, 해당 메소드가 실행되기 전에는 오류를 확인하기 힘들다는 단점이 있다.

#### SQL 제공 서비스
SQL을 꼭 스프링의 빈 설정 방법을 사용해 XML에 담아둘 이유도 없다. SQL을 편집하고 관리할 수 있는 툴에서 생성해주는 SQL 정보 파일이 있다면, 그런 파일 포맷 그대로 사용할 수 있어야 편할 것이다. 

SQL 제공 기능을 본격적으로 분리해서 다양한 SQL 정보 소스를 사용할 수 있고, 운영 중에 동적으로 갠신도 가능한 유연하고 확장성이 뛰어난 SQL 서비스를 만들어야 한다.
##### SQL 서비스 인터페이스
클라이언트인 DAO를 SQL 서비스의 구현에서 독립적으로 만들도록 인터페이스를 사용하고, DI로 구현 클래스의 오브젝트를 주입해주어야 한다.
* SqlService 인터페이스
```
public interface SqlService {
  String getSql(String key) throws SqlRetrievalFailureException; // 런타임 예외이므로 특별히 복구해야 할 필요가 없다면 무시해도 된다.
}
```
* 조회 실패 시 예외
```
public class SqlRetrievalFailureException extends RuntimeException {
  public SqlRetrievalFailureException(String message) {
    super(message);
  }
  
  // SQL을 가져오는 데 실패한 근본 원인을 담을 수 있도록 중첩 예외를 저장할 수 있는 생성자를 만들어둔다.
  public SqlRetrievalFailureException(String message, Throwable cause) {
    super(message, cause);
  }
}
```
* 맵을 이용한 SqlService의 구현
```
public class SimpleSqlService implements SqlService {
  // 설정파일에 <map>으로 정의된 SQL정보를 가져오도록 프로퍼티로 등록해둔다.
  private Map<String, String> sqlMap;
  
  public void setSqlMap(Map<String, String> sqlMap) {
    this.sqlMap = sqlMap;
  }
  
  public String getSql(String key) throws SqlRetrievalFailureException {
    String sql = sqlMap.get(key); // 내부 SqlMap에서 SQL을 가져온다.
    if (sql == null) // 인터페이스에 정의된 규약대로 SQL을 가져오는 데 실패하면 예외를 던지게 한다.
      throw new SqlRetrievalFailureException(key + "에 대한 SQL을 찾을 수 없습니다");
    else
      return sql;
  }
}
```
> UserDao를 포함한 모든 DAO는 SQL을 어디에 저장해두고 가져오는지에 대해서는 전혀 신경 쓰지 않아도 된다. 구체적인 구현 방법과 기술에 상관없이 SqlService 인터페이스 타입의 빈을 DI 받아서 필요한 SQL을 가져다 쓰기만 하면 된다.

> 동시에 sqlService 빈에는 DAO에는 전혀 영향을 주지 않은 채로 다양한 방법으로 구현된 SqlService 타입 클래스를 적용할 수 있다.
<hr/>

### 인터페이스의 분리와 자기참조 빈
#### XML 파일 매핑
스프링의 XML 설정파일에서 <bean> 태그 안에 SQL 정보를 넣어놓고 활용하는 건 좋은 방법이 아니다. 그보다는 SQL을 저장해두는 전용 포맷을 가진 독립적인 파일을 이용하는 편이 바람직하다. 가장 편리한 포맷은 역시 XML이다.
  
#### 빈의 초기화 작업
```
<context:annotation-config />
```
위 태그에 의해 등록되는 빈 후처리기는 몇 가지 특별한 빈 설정에 사용되는 애노테이션을 제공한다. @PostConstruct는 java.lang.annotation 패키지에 포함된 공통 애노테이션의 한 가지로 JavaEE 5나 JDK 6에 포함된 표준 애노테이션이다. 스프링은 @PostConstruct 애노테이션을 빈 오브젝트의 초기화 메소드를 지정하는 데 사용한다.
```
@PostConstruct // loadSql() 메소드를 빈의 초기화 메소드로 지정한다.
public void loadSql() {...}
```
위와 같이 사용하면 스프링은 클래스로 등록된 빈의 오브젝트를 생성하고 DI 작업을 마친 뒤에 @PostConstruct가 붙은 메소드를 자동으로 실행해준다. 생성자와는 달리 프로퍼티까지 모두 준비된 후에 실행된다는 면에서 @PostConstruct 초기화 메소드는 매우 유용하다.

* 스프링 컨테이너인 애플리케이션 컨텍스트가 XML 설정파일을 읽고 진행하는 작업의 순서
1. XML 빈 설정을 읽는다.
```applicationContext.xml```
2. 빈의 오브젝트를 생성한다. 
```<bean id=".." class="ClassName">```
3. 프로퍼티에 의존 오브젝트 또는 값을 주입한다.
```<property name=".." value="xyz" />```
```<property name=".." ref="beanId" />```
4. 빈이나 태그로 등록된 후처리기를 동작시킨다. 코드에 달린 애노테이션에 대한 부가 작업 진행
```@PostConstruct public void init() { ... }```
> @PostConstruct 애노테이션은 빈 오브젝트가 생성되고 의존 오브젝트와 설정 값을 넣어주는 DI 작업까지 마친 후에 호출된다. 따라서 @PostConstruct를 단 메소드의 코드는 모든 프로퍼티의 값이 준비됐다고 가정하고 적성하면 된다.
#### 변화를 위한 준비: 인터페이스 분리
##### 책임에 따른 인터페이스 정의
1. SQL 정보를 외부의 리소스로부터 읽어온다.
2. 읽어온 SQL을 보관해두고 있다가 필요할 때 제공해준다.(한 번 가져온 SQL을 필요에 따라 수정할 수도 있어야 한다.)
> 기본적으로 SqlService를 구현해서 DAO에 서비스를 제공해주는 오브젝트가 이 두 가지 책임을 가진 오브젝트와 협력해서 동작하도록 만들어야 한다. SqlService의 구현 클래스가 변경 가능한 책임을 가진 SqlReader와 SqlRegistry 두 가지 타입의 오브젝트를 사용하도록 만든다. 당연히 인터페이스를 이용하게 하고, DI를 통해 의존 오브젝트를 제공받게 해야 한다.
* SqlRegistry 인터페이스
```
public interface SqlRegistry {
  void registerSql(String key, String sql); // SQL을 키와 함께 등록한다.
  
  String findSql(String key) throws SqlNotFoundException; // 키로 SQL을 검색한다. 검색이 실패하면 예외를 던진다.
}
```
* SqlReader 인터페이스
```
public interface SqlReader {
  void read(SqlRegistry sqlRegistry); // SQL을 외부에서 가져와 SqlRegistry에 등록한다. 다양한 예외가 발생할 수 있겠지만
                                         대부분 복구 불가능한 예외이므로 굳이 예외를 선언해두지 않았다.
}
```
#### 자기참조 빈으로 시작하기
* 자신을 참조하는 sqlService 빈 설정
```
<bean id="sqlService" class="springbook.user.sqlservice.XmlSqlService">
  <property name="sqlReader" ref="sqlService" />
  <property name="sqlRegistry" ref="sqlService" />
  <property name="sqlmapFile" value="sqlmap.xml" />
</bean>
```
> 빈은 sqlService 하나만 선언했기에 실제 빈 오브젝트도 한 개만 만들어진다. 스프링은 프로퍼티의 ref 항목에 자기 자신을 넣는 것을 허용한다. 이를 통해, sqlService를 구현한 메소드와 초기화 메소드는 외부에서 DI 된 오브젝트라고 생각하고 결국 자신의 메소드에 접근한다.
#### 디폴트 의존관계
##### 디폴트 의존관계를 갖는 빈 만들기
확장을 고려해서 기능을 분리하고, 인터페이스와 전략 패턴을 도입하고, DI를 적용한다면 늘어난 클래스와 인터페이스 구현과 의존관계 설정에 대한 부담은 감수해야 한다. 특정 의존 오브젝트가 대부분의 환경에서 거의 디폴트라고 해도 좋을 만큼 기본적으로 사용될 가능성이 있다면, 디폴트 의존관계를 갖는 빈을 만드는 것을 고려해볼 필요가 있다.<br/>
> 디폴트 의존관계란 외부에서 DI 받지 않는 경우 기본적으로 자동 적용되는 의존관계를 말한다.<br/>
* 생성자를 통한 디폴트 의존관계 설정
```
public class DefaultSqlService extends BaseSqlService {
  public DefaultSqlService() {
    // 생성자에서 디폴트 의존 오브젝트를 직접 만들어서 스스로 DI 해준다.
    setSqlReader(new JaxbXmlSqlReader());
    setSqlRegistry(new HashMapSqlRegistry());
  }
}
```
> DI 설정이 없을 경우 디폴트로 적용하고 싶은 의존 오브젝트를 생성자에서 넣어준다. DI란 클라이언트 외부에서 의존 오브젝트를 주입해주는 것이지만 이렇게 자신이 사용할 디폴트 의존 오브젝트를 스스로 DI 하는 방법도 있다. 이렇게 코드를 통해 의존관계의 오브젝트를 직접 주입해주면 특별히 DI가 필요한 상황이 아닌 대부분의 경우에는 편리하게 사용할 수 있다.

디폴트 의존 오브젝트를 사용하는 방법은 설정을 통해 다른 구현 오브젝트를 사용하게 해도 생성자에서 일단 디폴트 의존 오브젝트를 다 만들어버리는 단점이 있따. 이럴 땐 @PostConstruct 초기화 메소드를 이용해 프로퍼티가 설정됐는지 확인하고 없는 경우에만 디폴트 오브젝트를 만드는 방법이 있따. 

> 아무튼 이렇게 해서 디폴트 의존 오브젝트와 값을 이용해 설정을 간단하게 해주고 미리 준비된 기능을 손쉽게 사용할 수 있으면서도, 필요한 부분은 언제든지 확장 가능한 구조를 갖는 빈으로 만들었다.
<hr/>

### 서비스 추상화 적용
* 자바에는 다양한 XML과 자바오브젝트를 매핑하는 기술이 있다. 필요에 따라 다른 기술로 손쉽게 바꿔서 사용할 수 있게 해야 한다.
* XML 파일을 좀 더 다양한 소스에서 가져올 수 있게 만든다. 임의의 클래스패스타 파일 시스템상의 절대위치 또는 HTTP 프로토콜을 통해 원격에서 가져오도록 확장할 수 있어야 한다.
#### OXM 서비스 추상화
XML과 자바오브젝트를 매핑해서 상호 변환해주는 기술을 간단히 OXM(Object-XML Mapping)이라고 한다.

OXM 프레임워크와 기술들은 기능 면에서 상호 호환성이 있다. 모두 사용 목적이 동일하기 때문에 유사한 기능과 API를 제공한다. 기능이 같은 여러 가지 기술이 존재한다는 이야기가 나오면 떠오르는 게 있다. 바로 서비스 추상화다. 로우레벨의 구체적인 기술과 API에 종속되지 않고 추상화된 레이어와 API를 제공해서 구현 기술에 대해 독립적인 코드를 작성할 수 있게 해주는 서비스 추상화가 필요하다.

스프링이 제공하는 OXM 추상 계층의 API를 이용해 XML 문서와 오브젝트 사이의 변환을 처리하게 하면, 코드 수정 없이도 OXM 기술을 자유롭게 바꿔서 적용할 수 있다.
##### OXM 서비스 인터페이스
스프링이 제공하는 OXM 추상화 서비스 인터페이스에는 자바오브젝트를 XML로 변환하는 Marshaller와, 반대로 XML을 자바오브젝트로 변환하는 Unmarshaller가 있다.
* Unmarshaller 인터페이스
```
package org.springframework.oxm; // spring-oxm 모듈 안에 정의되어 있다.
...
import javax.xml.transform.Source;

public interface Unmarshaller {
  boolean supports(Class<?> clazz); // 해당 클래스로 언마샬이 가능한지 확인해준다. 별로 사용할 일은 없다.
  
  Object unmarshal(Source source) throws IOException, XmlMappingException; // Source를 통해 제공받은 XML을 자바오브젝트
                                                                              트리로 변환해서 그 루트 오브젝트를 돌려준다.
}
```
> OXM 기술에 따라 Unmarshaller 인터페이스를 구현한 클래스가 있다. 각 클래스는 해당 기술에서 필요로 하는 추가 정보를 빈 프로퍼티로 지정할 수 있게 되어 있다.

> 서비스 추상화는 로우레벨의 기술을 필요에 따라 변경해서 사용하더라도 일관된 애플리케이션 코드를 유지할 수 있게 해준다.
#### OXM 서비스 추상화 적용
##### 멤버 클래스를 참조하는 통합 클래스
```
public class OxmSqlService implements SqlService {
  // OxmSqlService와 OxmSqlReader는 강하게 결합돼서 하나의 빈으로 등록되고 한 번에 설정할 수 있다.
  private final OxmSqlReader oxmSqlReader = new OxmSqlReader(); // final이므로 변경 불가능 하다.
  ...
  
  // private 멤버 클래스로 정의한다. 톱레벨 클래스인 OxmSqlService만이 사용할 수 있다.
  private class OxmSqlReader implements SqlReader {
    ...
  }
}
```
> OxmSqlReader는 priavate 멤버 클래스이므로 외부에서 접근하거나 사용할 수 없다. 또한 OxmSqlService는 이를 final로 선언하고 직접 오브젝트를 생성하기 때문에 OxmSqlReader를 DI 하거나 변경할 수 없다.

> 하나의 클래스로 만들어두기 때문에 빈의 등록과 설정은 단순해지고 쉽게 사용할 수 있다.
#### 리소스 추상화
클래스패스 루트 등에 있는 XML 파일, 상대적인 클래스패스가 아니라 서버나 개발 시스템의 특정 폴더에 있는 파일, 서블릿 컨텍스트의 상대적인 폴더나 http, ftp 프로토콜로 접근할 수 있는 웹상의 리소스 파일을 가져오려면?

자바에는 이렇게 다양한 위치에 존재하는 리소스에 대한 단일화된 접근 인터페이스를 제공해주는 클래스가 없다. 
##### 리소스
스프링은 자바에 존재하는 일관성 없는 리소스 접근 API를 추상화해서 Resource라는 추상화 인터페이스를 정의했다.
* Resource 인터페이스
```
public interface Resource extends InputStreamSource {
  // 리소스의 존재나 읽기 가능한지 여부를 확인할 수 있다.
     또 현재 리소스에 대한 입력 스트림이 열려 있는지도 확인 가능하다.
  boolean exists();
  boolean isReadable();
  boolean isOpen();
  
  // JDK의 URL, URI, File 형태로 전환 가능한 리소스에 사용된다.
  URL getURL() throws IOException;
  URI getURI() throws IOException;
  File getFile() throws IOException;
  
  Resource createRelative(String relativePath) throws IOException;
  
  // 리소스에 대한 이름과 부가적인 정보를 제공한다.
  long lastModified() throws IOException;
  String getFilename();
  String getDescription();
}

public interface InputStreamSource {
  InputStream getInputStream() throws IOException; // 모든 리소스는 InputStream형태로 가져올 수 있다.
}
```
> 애플리케이션 컨텍스트가 사용할 설정정보 파일을 지정하는 것부터 시작해서 스프링의 거의 모든 API는 외부의 리소스 정보가 필요할 때는 항상 이 Resource 추상화를 이용한다.

다른 서비스 추상화의 오브젝트와는 달리, Resource는 스프링에서 빈이 아니라 값으로 취급된다. 리소스는 OXM이나 트랜잭션처럼 서비스를 제공해주는 것이 아니라 단순한 정보를 가진 값으로 지정된다.

그래서 추상화를 적용하는 방법이 문제다. ```<property>```의 value 애트리뷰트에 넣는 방법밖에 없다. 하지만 value 애트리뷰트에 넣을 수 있는 건 단순한 문자열 뿐이다.
##### 리소스 로더
그래서 스프링에는 URL 클래스와 유사하게 접두어를 이용해 Resource 오브젝트를 선언하는 방법이 있다. 문자열 안에 리소스의 종류와 리소스의 위치를 함께 표현하게 해주는 것이다. 그리고 이렇게 문자열로 정의된 리소스를 실제 Resource 타입 오브젝트로 변환해주는 ResourceLoader를 제공한다.
* ResourceLoader 인터페이스
```
public interface ResourceLoader {
  Resource getResource(String location); // location에 담긴 스트링 정보를 바탕으로
  ...                                       그에 적절한 Resource로 변환해준다.
}
```
> 접두어가 없는 경우에는 리소스 로더의 구현 방식에 따라 리소스를 가져오는 방식이 달라진다. 하지만 접두어를 붙여주면 리소스 로더의 종류와 상관없이 접두어가 의미하는 위치와 방법을 이용해 리소스를 읽어온다.
* ResourceLoader가 처리하는 접두어의 예

접두어 | 예 | 설명
:-----:|:----:|:----:
file: | file:/C:/temp/file.txt | 파일 시스템의 C:/temp 폴더에 있는 file.txt를 리소스로 만들어준다.
classpath: | classpath:file.txt | 클래스패스의 루트에 존재하는 file.txt 리소스에 접근하게 해준다.
없음 | WEN-INF/test.dat | 접두어가 없는 경우에는 ResourceLoader 구현에 따라 리소스의 위치가 결정된다. ServletResourceLoader라면 서블릿 컨텍스트의 루트를 기준으로 해석한다.
http: | http://www.myserver.com/test.dat | HTTP 프로토콜을 사용해 접근할 수 있는 웹상의 리소스를 지정한다. ftp:도 사용할 수 있다.

> ResourceLoader의 대표적인 예는 바로 스프링의 애플리케이션 컨텍스트다. 애플리케이션 컨텍스트가 구현해야 하는 인터페이스인 ApplicationContext는 ResourceLoader 인터페이스를 상속하고 있다. 따라서 모든 애플리케이션 컨텍스트는 리소스 로더이기도 하다.
##### Resource를 이용해 XML 파일 가져오기
Resource를 사용할 때는 Resource 오브젝트가 실제 리소스는 아니라는 점을 주의해야 한다. Resource는 단지 리소스에 접근할 수 있는 추상화된 핸들러일 뿐이다. 따라서 Resource 타입의 오브젝트가 만들어졌다고 해도 실제로 리소스가 존재하지 않을 수 있다.

기존의 sqlmapFile과 마찬가지로 sqlmap 리소스도 디폴트를 설정해준다. UserDao와 같은 클래스패스 안의 sqlmap.xml 파일을 클래스패스 리소스로 지정해주면 된다. 코드에서 클래스패스 리소스를 바로 지정하고 싶다면 ClassPathResource를 사용해 오브젝트를 만들면 된다.

반면에 문자열로 지정할 때는 리소스 로더가 인식할 수 있는 문자열로 표현해주면 된다.
* classpath: 접두어를 이용해 지정한 리소스
```
<bean id-"sqlService" class="springbook.user.sqlservice.OxmSqlService">
  <property name="unmarshaller" ref="unmarshaller" />
  <property name="sqlmap" value="classpath:springbook/user/dao/sqlmap.xml" />
  // classpath:는 디폴트이므로 생략 가능하다. 클래스패스 위치를 지정할 때는 클래스패스 루트부터 절대위치를 적어야 한다.
</bean>
```
* file: 접두어를 이용해 지정한 리소스
```
<bean id-"sqlService" class="springbook.user.sqlservice.OxmSqlService">
  <property name="unmarshaller" ref="unmarshaller" />
  <property name="sqlmap" value="file:/opt/resources/sqlmap.xml" />
</bean>
```
* HTTP로 접근 가능한 리소스
```
<bean id-"sqlService" class="springbook.user.sqlservice.OxmSqlService">
  <property name="unmarshaller" ref="unmarshaller" />
  <property name="sqlmap" value="http://www.epril.com/resources/sqlmap.xml" />
</bean>
```
> 스프링의 리소스 추상화를 이용하면 리소스의 위치와 접근 방법에 독립적인 코드를 쉽게 만들 수 있다. 스프링 애플리케이션에서 파일을 읽거나 참조하는 기능을 만들 때는 Resource 타입의 추상화 기능을 사용하면 된다.
<hr/>

### 인터페이스 상속을 통한 안전한 기능확장
