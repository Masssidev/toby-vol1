# 스프링 핵심 기술의 응용
### SQL과 DAO의 분리
SQL 변경이 필요한 상황이 발생하면 SQL을 담고 있는 DAO 코드가 수정될 수밖에 없다.
#### XML 설정을 이용한 분리
스프링은 설정을 이용해 빈에 값을 주입해줄 수 있다. SQL은 문자열로 되어 있으니 설정파일에 프로퍼티 값으로 정의해서 DAO에 주입해줄 수 있다. 이렇게 하면 설정파일에 있는 SQL을 코드와는 독립적으로 수정할 수가 있다.
##### 개별 SQL 프로퍼티 방식
* add() 메소드를 위한 SQL 필드
```
public class UserDaoJdbc implements UserDao {
  private String sqlAdd;
  
  public void setSqlAdd(String sqlAdd) {
    this.sqlAdd = sqlAdd;
  }
}
```
* 주입받은 SQL 사용
```
public void add(User user) {
  this.jdbcTemplate.update(
    this.sqlAdd, // "insert into users..."를 제거하고 외부에서 주입받은 SQL을 사용하게 한다.
    user.getId(), user.getNamq(), user.getPassword(), user.getEmail(),
    user.getLevel().intValue(), user.getLogin(), user.getRecommend());
  )
}
```
* 설정파일에 넣은 SQL 문장
```
<bean id="userDao" class="springbook.user.dao.UserDaoJdbc">
  <property name="dataSource ref="dataSource" />
  <property name="sqlAdd" value="insert into users(id, name, password, email, level, login, recommend)
     values(?,?,?,?,?,?,?)" />
  ...
```
> 스프링에서는 스트링 값을 외부에서 DI 해서 사용할 수 있기 때문에 손쉽게 SQL을 분리하는 데 성공했다. 하지만 이 방법은 매번 새로운 SQL이 필요할 때마다 프로퍼티를 추가하고 DI를 위한 변수와 수정자 메소드도 만들어줘야 하기 때문에 불편하다.

##### SQL 맵 프로퍼티 방식
SQL을 하나의 컬렉션으로 담아두는 방법
* 맵 타입의 SQL 정보 프로퍼티
```
public class UserDaoJdbc implements UserDao {
  ...
  private Map<String, String> sqlMap;
  
  public void setSqlMap(Map<String, String> sqlMap) {
    this.sqlMap = sqlMap;
  }
}
```
* sqlMap을 사용하도록 수정한 add()
```
public void add(User user) {
  this.jdbcTemplate.update(
    this.sqlMap.get("add"), // 프로퍼티로 제공받은 맵으로부터 키를 이용해서 필요한 SQL을 가져온다.
    user.getId(), user.getNamq(), user.getPassword(), user.getEmail(),
    user.getLevel().intValue(), user.getLogin(), user.getRecommend());
  )
}
```
* 맵을 이용한 SQL 설정
```
<bean id="userDao" class="springbook.user.dao.UserDaoJdbc">
  <property name="dataSource ref="dataSource" />
  <property name="sqlMap">
    <map>
      <entry key="add" value="insert into users(id, name, password, email, level, login, recommend)
        values(?,?,?,?,?,?,?)" />
      <entry key="get" value="select * from users where id = ?" />
      <entry key="getAll" value="select * from users order by id" />
      <entry key="deleteAll" value="delete from users" />
      <entry key="getCount" value="select count(*) from users" />
      <entry key="update" value="update users set name = ?, password = ?,
        email = ?, level = ?, login = ?, recommend = ? where id = ?" />
    </map>
  </property>
</bean>
```
> 맵으로 만들어두면 새로운 SQL이 필요할 때 설정에 entry만 추가해주면 되니 모든 SQL을 일일이 프로퍼티로 등록하는 방법에 비해 작업량도 적고 코드도 간단해서 좋다. 대신 메소드에서 SQL을 가져올 때 문자열로 된 키 값을 사용하기 때문에 오타와 같은 실수가 있어도, 해당 메소드가 실행되기 전에는 오류를 확인하기 힘들다는 단점이 있다.

#### SQL 제공 서비스
SQL을 꼭 스프링의 빈 설정 방법을 사용해 XML에 담아둘 이유도 없다. SQL을 편집하고 관리할 수 있는 툴에서 생성해주는 SQL 정보 파일이 있다면, 그런 파일 포맷 그대로 사용할 수 있어야 편할 것이다. 

SQL 제공 기능을 본격적으로 분리해서 다양한 SQL 정보 소스를 사용할 수 있고, 운영 중에 동적으로 갠신도 가능한 유연하고 확장성이 뛰어난 SQL 서비스를 만들어야 한다.
##### SQL 서비스 인터페이스
클라이언트인 DAO를 SQL 서비스의 구현에서 독립적으로 만들도록 인터페이스를 사용하고, DI로 구현 클래스의 오브젝트를 주입해주어야 한다.
* SqlService 인터페이스
```
public interface SqlService {
  String getSql(String key) throws SqlRetrievalFailureException; // 런타임 예외이므로 특별히 복구해야 할 필요가 없다면 무시해도 된다.
}
```
* 조회 실패 시 예외
```
public class SqlRetrievalFailureException extends RuntimeException {
  public SqlRetrievalFailureException(String message) {
    super(message);
  }
  
  // SQL을 가져오는 데 실패한 근본 원인을 담을 수 있도록 중첩 예외를 저장할 수 있는 생성자를 만들어둔다.
  public SqlRetrievalFailureException(String message, Throwable cause) {
    super(message, cause);
  }
}
```
* 맵을 이용한 SqlService의 구현
```
public class SimpleSqlService implements SqlService {
  // 설정파일에 <map>으로 정의된 SQL정보를 가져오도록 프로퍼티로 등록해둔다.
  private Map<String, String> sqlMap;
  
  public void setSqlMap(Map<String, String> sqlMap) {
    this.sqlMap = sqlMap;
  }
  
  public String getSql(String key) throws SqlRetrievalFailureException {
    String sql = sqlMap.get(key); // 내부 SqlMap에서 SQL을 가져온다.
    if (sql == null) // 인터페이스에 정의된 규약대로 SQL을 가져오는 데 실패하면 예외를 던지게 한다.
      throw new SqlRetrievalFailureException(key + "에 대한 SQL을 찾을 수 없습니다");
    else
      return sql;
  }
}
```
> UserDao를 포함한 모든 DAO는 SQL을 어디에 저장해두고 가져오는지에 대해서는 전혀 신경 쓰지 않아도 된다. 구체적인 구현 방법과 기술에 상관없이 SqlService 인터페이스 타입의 빈을 DI 받아서 필요한 SQL을 가져다 쓰기만 하면 된다.

> 동시에 sqlService 빈에는 DAO에는 전혀 영향을 주지 않은 채로 다양한 방법으로 구현된 SqlService 타입 클래스를 적용할 수 있다.
<hr/>

### 인터페이스의 분리와 자기참조 빈
