# 스프링 핵심 기술의 응용
### SQL과 DAO의 분리
SQL 변경이 필요한 상황이 발생하면 SQL을 담고 있는 DAO 코드가 수정될 수밖에 없다.
#### XML 설정을 이용한 분리
스프링은 설정을 이용해 빈에 값을 주입해줄 수 있다. SQL은 문자열로 되어 있으니 설정파일에 프로퍼티 값으로 정의해서 DAO에 주입해줄 수 있다. 이렇게 하면 설정파일에 있는 SQL을 코드와는 독립적으로 수정할 수가 있다.
##### 개별 SQL 프로퍼티 방식
* add() 메소드를 위한 SQL 필드
```
public class UserDaoJdbc implements UserDao {
  private String sqlAdd;
  
  public void setSqlAdd(String sqlAdd) {
    this.sqlAdd = sqlAdd;
  }
}
```
* 주입받은 SQL 사용
```
public void add(User user) {
  this.jdbcTemplate.update(
    this.sqlAdd, // "insert into users..."를 제거하고 외부에서 주입받은 SQL을 사용하게 한다.
    user.getId(), user.getNamq(), user.getPassword(), user.getEmail(),
    user.getLevel().intValue(), user.getLogin(), user.getRecommend());
  )
}
```
* 설정파일에 넣은 SQL 문장
```
<bean id="userDao" class="springbook.user.dao.UserDaoJdbc">
  <property name="dataSource ref="dataSource" />
  <property name="sqlAdd" value="insert into users(id, name, password, email, level, login, recommend)
     values(?,?,?,?,?,?,?)" />
  ...
```
> 스프링에서는 스트링 값을 외부에서 DI 해서 사용할 수 있기 때문에 손쉽게 SQL을 분리하는 데 성공했다. 하지만 이 방법은 매번 새로운 SQL이 필요할 때마다 프로퍼티를 추가하고 DI를 위한 변수와 수정자 메소드도 만들어줘야 하기 때문에 불편하다.

##### SQL 맵 프로퍼티 방식
SQL을 하나의 컬렉션으로 담아두는 방법
* 맵 타입의 SQL 정보 프로퍼티
```
public class UserDaoJdbc implements UserDao {
  ...
  private Map<String, String> sqlMap;
  
  public void setSqlMap(Map<String, String> sqlMap) {
    this.sqlMap = sqlMap;
  }
}
```
* sqlMap을 사용하도록 수정한 add()
```
public void add(User user) {
  this.jdbcTemplate.update(
    this.sqlMap.get("add"), // 프로퍼티로 제공받은 맵으로부터 키를 이용해서 필요한 SQL을 가져온다.
    user.getId(), user.getNamq(), user.getPassword(), user.getEmail(),
    user.getLevel().intValue(), user.getLogin(), user.getRecommend());
  )
}
```
* 맵을 이용한 SQL 설정
```
<bean id="userDao" class="springbook.user.dao.UserDaoJdbc">
  <property name="dataSource ref="dataSource" />
  <property name="sqlMap">
    <map>
      <entry key="add" value="insert into users(id, name, password, email, level, login, recommend)
        values(?,?,?,?,?,?,?)" />
      <entry key="get" value="select * from users where id = ?" />
      <entry key="getAll" value="select * from users order by id" />
      <entry key="deleteAll" value="delete from users" />
      <entry key="getCount" value="select count(*) from users" />
      <entry key="update" value="update users set name = ?, password = ?,
        email = ?, level = ?, login = ?, recommend = ? where id = ?" />
    </map>
  </property>
</bean>
```
> 맵으로 만들어두면 새로운 SQL이 필요할 때 설정에 entry만 추가해주면 되니 모든 SQL을 일일이 프로퍼티로 등록하는 방법에 비해 작업량도 적고 코드도 간단해서 좋다. 대신 메소드에서 SQL을 가져올 때 문자열로 된 키 값을 사용하기 때문에 오타와 같은 실수가 있어도, 해당 메소드가 실행되기 전에는 오류를 확인하기 힘들다는 단점이 있다.

#### SQL 제공 서비스
SQL을 꼭 스프링의 빈 설정 방법을 사용해 XML에 담아둘 이유도 없다. SQL을 편집하고 관리할 수 있는 툴에서 생성해주는 SQL 정보 파일이 있다면, 그런 파일 포맷 그대로 사용할 수 있어야 편할 것이다. 

SQL 제공 기능을 본격적으로 분리해서 다양한 SQL 정보 소스를 사용할 수 있고, 운영 중에 동적으로 갠신도 가능한 유연하고 확장성이 뛰어난 SQL 서비스를 만들어야 한다.
##### SQL 서비스 인터페이스
클라이언트인 DAO를 SQL 서비스의 구현에서 독립적으로 만들도록 인터페이스를 사용하고, DI로 구현 클래스의 오브젝트를 주입해주어야 한다.
* SqlService 인터페이스
```
public interface SqlService {
  String getSql(String key) throws SqlRetrievalFailureException; // 런타임 예외이므로 특별히 복구해야 할 필요가 없다면 무시해도 된다.
}
```
* 조회 실패 시 예외
```
public class SqlRetrievalFailureException extends RuntimeException {
  public SqlRetrievalFailureException(String message) {
    super(message);
  }
  
  // SQL을 가져오는 데 실패한 근본 원인을 담을 수 있도록 중첩 예외를 저장할 수 있는 생성자를 만들어둔다.
  public SqlRetrievalFailureException(String message, Throwable cause) {
    super(message, cause);
  }
}
```
* 맵을 이용한 SqlService의 구현
```
public class SimpleSqlService implements SqlService {
  // 설정파일에 <map>으로 정의된 SQL정보를 가져오도록 프로퍼티로 등록해둔다.
  private Map<String, String> sqlMap;
  
  public void setSqlMap(Map<String, String> sqlMap) {
    this.sqlMap = sqlMap;
  }
  
  public String getSql(String key) throws SqlRetrievalFailureException {
    String sql = sqlMap.get(key); // 내부 SqlMap에서 SQL을 가져온다.
    if (sql == null) // 인터페이스에 정의된 규약대로 SQL을 가져오는 데 실패하면 예외를 던지게 한다.
      throw new SqlRetrievalFailureException(key + "에 대한 SQL을 찾을 수 없습니다");
    else
      return sql;
  }
}
```
> UserDao를 포함한 모든 DAO는 SQL을 어디에 저장해두고 가져오는지에 대해서는 전혀 신경 쓰지 않아도 된다. 구체적인 구현 방법과 기술에 상관없이 SqlService 인터페이스 타입의 빈을 DI 받아서 필요한 SQL을 가져다 쓰기만 하면 된다.

> 동시에 sqlService 빈에는 DAO에는 전혀 영향을 주지 않은 채로 다양한 방법으로 구현된 SqlService 타입 클래스를 적용할 수 있다.
<hr/>

### 인터페이스의 분리와 자기참조 빈
#### XML 파일 매핑
스프링의 XML 설정파일에서 <bean> 태그 안에 SQL 정보를 넣어놓고 활용하는 건 좋은 방법이 아니다. 그보다는 SQL을 저장해두는 전용 포맷을 가진 독립적인 파일을 이용하는 편이 바람직하다. 가장 편리한 포맷은 역시 XML이다.
  
#### 빈의 초기화 작업
```
<context:annotation-config />
```
위 태그에 의해 등록되는 빈 후처리기는 몇 가지 특별한 빈 설정에 사용되는 애노테이션을 제공한다. @PostConstruct는 java.lang.annotation 패키지에 포함된 공통 애노테이션의 한 가지로 JavaEE 5나 JDK 6에 포함된 표준 애노테이션이다. 스프링은 @PostConstruct 애노테이션을 빈 오브젝트의 초기화 메소드를 지정하는 데 사용한다.
```
@PostConstruct // loadSql() 메소드를 빈의 초기화 메소드로 지정한다.
public void loadSql() {...}
```
위와 같이 사용하면 스프링은 클래스로 등록된 빈의 오브젝트를 생성하고 DI 작업을 마친 뒤에 @PostConstruct가 붙은 메소드를 자동으로 실행해준다. 생성자와는 달리 프로퍼티까지 모두 준비된 후에 실행된다는 면에서 @PostConstruct 초기화 메소드는 매우 유용하다.

* 스프링 컨테이너인 애플리케이션 컨텍스트가 XML 설정파일을 읽고 진행하는 작업의 순서
1. XML 빈 설정을 읽는다.
```applicationContext.xml```
2. 빈의 오브젝트를 생성한다. 
```<bean id=".." class="ClassName">```
3. 프로퍼티에 의존 오브젝트 또는 값을 주입한다.
```<property name=".." value="xyz" />```
```<property name=".." ref="beanId" />```
4. 빈이나 태그로 등록된 후처리기를 동작시킨다. 코드에 달린 애노테이션에 대한 부가 작업 진행
```@PostConstruct public void init() { ... }```
> @PostConstruct 애노테이션은 빈 오브젝트가 생성되고 의존 오브젝트와 설정 값을 넣어주는 DI 작업까지 마친 후에 호출된다. 따라서 @PostConstruct를 단 메소드의 코드는 모든 프로퍼티의 값이 준비됐다고 가정하고 적성하면 된다.
#### 변화를 위한 준비: 인터페이스 분리
##### 책임에 따른 인터페이스 정의
1. SQL 정보를 외부의 리소스로부터 읽어온다.
2. 읽어온 SQL을 보관해두고 있다가 필요할 때 제공해준다.(한 번 가져온 SQL을 필요에 따라 수정할 수도 있어야 한다.)
> 기본적으로 SqlService를 구현해서 DAO에 서비스를 제공해주는 오브젝트가 이 두 가지 책임을 가진 오브젝트와 협력해서 동작하도록 만들어야 한다. SqlService의 구현 클래스가 변경 가능한 책임을 가진 SqlReader와 SqlRegistry 두 가지 타입의 오브젝트를 사용하도록 만든다. 당연히 인터페이스를 이용하게 하고, DI를 통해 의존 오브젝트를 제공받게 해야 한다.
* SqlRegistry 인터페이스
```
public interface SqlRegistry {
  void registerSql(String key, String sql); // SQL을 키와 함께 등록한다.
  
  String findSql(String key) throws SqlNotFoundException; // 키로 SQL을 검색한다. 검색이 실패하면 예외를 던진다.
}
```
* SqlReader 인터페이스
```
public interface SqlReader {
  void read(SqlRegistry sqlRegistry); // SQL을 외부에서 가져와 SqlRegistry에 등록한다. 다양한 예외가 발생할 수 있겠지만
                                         대부분 복구 불가능한 예외이므로 굳이 예외를 선언해두지 않았다.
}
```
#### 자기참조 빈으로 시작하기
* 자신을 참조하는 sqlService 빈 설정
```
<bean id="sqlService" class="springbook.user.sqlservice.XmlSqlService">
  <property name="sqlReader" ref="sqlService" />
  <property name="sqlRegistry" ref="sqlService" />
  <property name="sqlmapFile" value="sqlmap.xml" />
</bean>
```
> 빈은 sqlService 하나만 선언했기에 실제 빈 오브젝트도 한 개만 만들어진다. 스프링은 프로퍼티의 ref 항목에 자기 자신을 넣는 것을 허용한다. 이를 통해, sqlService를 구현한 메소드와 초기화 메소드는 외부에서 DI 된 오브젝트라고 생각하고 결국 자신의 메소드에 접근한다.
#### 디폴트 의존관계
