# 서비스 추상화
### 사용자 레벨 관리 기능 추가
* 사용자의 레벨은 BASIC, SILVER, GOLD 세 가지 중 하나다.
* 사용자가 처음 가입하면 BASIC 레벨이 되며, 이후 활동에 따라서 한 단계씩 업그레이드될 수 있다.
* 가입 후 50회 이상 로그인을 하면 BASIC에서 SILVER 레벨이 된다.
* SILVER 레벨이면서 30번 이상 추천을 받으면 GOLD 레벨이 된다.
* 사용자 레벨의 변경 작업은 일정한 주기를 가지고 일괄적으로 진행된다. 변경 작업 전에는 조건을 충족하더라도 레벨의 변경이 일어나지 않는다.

#### 필드 추가
###### Level 이늄
DB에 varchar 타입으로 선언하고 "BASIC", "SILVER, "GOLD"라고 문자를 넣는 방법보다는 각 레벨을 코드화해서 숫자로 넣는다. 범위가 작은 숫자로 관리하면 DB 
용량도 많이 차지하지 않고 가벼워서 좋다.

자바의 User에 추가할 프로퍼티 타입은 의미없는 숫자를 프로퍼티에 사용하면 타입이 안전하지 않아서 위험할 수 있기 때문에 별로 좋지 않다. 또, final 상수로 정의해도 
타입이 int이기 때문에 다른 종류의 정보를 넣는 실수를 해도 컴파일러가 체크해주지 못한다.

> 그래서 숫자 타입을 직접 사용하는 것보다는 자바 5 이상에서 제공하는 이늄(enum)을 이용하는게 안전하고 편리하다.
```
public enum Level {
  BASIC(1), SILVER(2), GOLD(3); // 세 개의 이늄 오브젝트 정의
  
  private final int value;
  
  Level(int value) { // DB에 저장할 값을 넣어줄 생성자.
    this.value = value;
  }
  
  public int intValue { // 값을 가져오는 메소드
    return value;
  }
  
  public static Level valueOf(int value) { // 값으로부터 Level 타입 오브젝트를 가져오도록 만든 스태틱 메소드
    switch(value) {
      case 1: return BASIC;
      case 2: return SILVER;
      case 3: return GOLD;
      default: throw new AssertionError("Unknown value: " + value);
    }
  }
}
```
> 이렇게 만들어진 Level 이늄은 내부에는 DB에 저장할 int 타입의 값을 갖고 있지만, 겉으로는 Level 타입의 오브젝트이기 때문에 안전하게 사용할 수 있다.
user1.setLevel(1000)과 같은 코드는 컴파일러가 타입이 일치하지 않는다는 에러를 내면서 걸러줄 것이다.

###### User 필드 추가 (로그인 횟수와 추천수도)
```
public class User {
  ...
  Level level;
  int login;
  int recommend;
  
  public Level getLevel() {
    return level;
  }
  
  public void setLevel(Level level) {
    this.level = level;
  }
  ...
  // login, recommend getter/setter 생략
}
```
add() 메소드의 경우 Level 이늄은 오브젝트이므로 DB에 저장될 수 있는 SQL 타입이 아니다. 따라서 DB에 저장 가능한 정수형 값으로 변환해줘야 한다. 각 
Level 이늄의 DB 저장용 값을 얻기 위해서는 Level에 미리 만들어둔 intValue() 메소드를 사용한다.

반대로 조회를 했을 경우, ResultSet에서는 DB의 타입인 int로 level 정보를 가져온다. 이 값을 User의 setLevel() 메소드에 전달하면 타입이 일치하지 않는다는 
에러가 발생할 것이다. 이 때는 Level의 스태틱 메소드는 valueOf()를 이용해 int 타입의 값을 Level 타입의 이늄 오브젝트로 만들어서 setLevel() 메소드에 
넣어줘야 한다.

#### UserService.upgradeLevels(), UserService.add()
DAO는 데이터를 어떻게 가져오고 조작할지를 다루는 곳이다. 비즈니스 로직을 두는 곳이 아니다. 따라서 비즈니스 로직을 담을 클래스를 새로 추가한다.

#### 코드 개선
* 코드에 중복된 부분은 없는가?
* 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가?
* 코드가 자신이 있어야 할 자리에 있는가?
* 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고, 그 변화에 쉽게 대응할 수 있게 작성되어 있는가?

###### upgradeLevels() 메소드 코드의 문제점
```
if (user.getLevel() == Level.BASIC && user.getLogin() >= 50) { // 현재 레벨이 무엇인지 파악, 업그레이드 조건
  user.setLevel(Level.SILVER); // 레벨 설정
  changed = true; // 변화체크
}
...

if(changed) { userDao.upgrade(user); }  // 변화가 있다면 upgrade
```

###### upgradeLevels() 리팩토링
```
public void upgrade Levels() {
  List<User> users = userDao.getAll();
  for(User user : users) {
    if (canUpgradeLevel(user)) {
      upgradeLevel(user);
    }
  }
}

private boolean canUpgradeLevel(User user) {
  Level currentLevel = user.getLevel();
  switch(currentLevel) { // 레벨별로 구분해서 조건을 판단
    case BASIC: return (user.getLogin() >= 50);
    case SILVER: return (user.getRecommend() >= 30);
    case GOLD: return false;
    // 현재 로직에서 다룰 수 없는 레벨이 주어지면 예외를 발생시킨다.
       새로운 레벨이 추가되고 로직을 수정하지 않으면 에러가 나서 확인할 수 있다.
    default: throw new IllegalArgumentException("Unknown Level: " + currentLevel);
  }
}
```
업그레이드 작업용 메소드를 따로 분리해두면 나중에 작업 내용이 추가되더라도 어느 고을 수정해야 할지가 명확해진다.
```
private void upgradeLevel(User user) {
  if (user.getLevel() == Level.BASIC) user.setLevel(Level.SILVER);
  else if (user.getLevel() == Level.SILVER) user.setLevel(Level.GOLD);
  userDao.update(user);
}
```
레벨의 순서와 다음 단계 레벨이 무엇인지를 결정하는 일은 Level에게 맡기자.
```
public enum Level {
  BASIC(1, SILVER), SILVER(2, GOLD), GOLD(3, null); // DB에 저장할 값과 다음 단계의 레벨 정보도 추가.
  
  private final int value;
  private fianl Level next; // 다음 단계의 레벨 정보를 스스로 갖고 있도록
  
  Level(int value, Level next) { 
    this.value = value;
    this.next = next;
  }
  
  public int intValue { // 값을 가져오는 메소드
    return value;
  }
  
  public Level nextLevel { // 값을 가져오는 메소드
    return this.next;;
  }
  
  public static Level valueOf(int value) { // 값으로부터 Level 타입 오브젝트를 가져오도록 만든 스태틱 메소드
    switch(value) {
      case 1: return BASIC;
      case 2: return SILVER;
      case 3: return GOLD;
      default: throw new AssertionError("Unknown value: " + value);
    }
  }
}
```
> 이렇게 만들어두면 레벨의 업그레이드 순서는 Level 이늄 안에서 관리할 수 있다. 다음 단계의 레벨이 무엇인지를 일일이 if 조건식을 만들어서 비즈니스 로직에 
담아둘 필요가 없다.

사용자 정보가 바뀌는 부분을 UserSErvice 메소드에서 User로 옮기자.
```
public void upgradeLevel() {
  Level nextLevel = this.level.nextLevel();
  if (nextLevel == null) {
    throw new IllegalStateException(this.level + "은 업그레이드가 불가능합니다");
  }
  else {
    this.level = nextLevel;
  }
}
```

간결해진 upgradeLevel()
```
private void upgradeLevel(User user) {
  user.upgradeLevel();
  userDao.update(user);
}
```
> if 문장이 많이 들어 있던 이전 코드보다 간결하고 작업 내용이 명확하게 드러나는 코드가 됐다. 각 오브젝트가 해야 할 책임도 깔끔하게 분리가 됐다.

> 숫자의 중복 또한 정수형 상수로 변경하여 사용하는 것이 좋다. 업그레이드 조건이 바뀌더라도 상수 값만 변경해주면 된다.
<hr/>

### 트랜잭션 서비스 추상화
