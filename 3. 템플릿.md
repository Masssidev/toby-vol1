# 템플릿
개방 폐쇄 원칙은 코드에서 어떤 부분은 변경을 통해 그 기능이 다양해지고 확장하려는 성질이 있고, 어떤 부분은 고정되어 있고 변하지 않으려는 성질이 있음을 
말해준다. 변화의 특성이 다른 부분을 구분해주고, 각각 다른 목적과 다른 이유에 의해 다른 시점에 독립적으로 변경될 수 있는 효율적인 구조를 만들어주는 것이 
바로 이 개방 폐쇄 원칙이다.

템플릿이란 이렇게 바뀌는 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 
부분으로부터 독립시켜서 효과적으로 활용할 수 있도록 하는 방법이다.
<hr/>

### 다시 보는 초난감 DAO
#### 예외처리 기능을 갖춘 DAO
일반적으로 서버에서는 제한된 개수의 DB 커넥션을 만들어서 재사용 가능한 풀로 관리한다. DB 풀은 매번 getConnection() 으로 가져간 커넥션을 명시적으로 
close() 해서 돌려줘야지만 다시 풀에 넣었다가 다음 커넥션 요청이 있을 때 재사용할 수 있다. 그런데 오류가 날 때마다 미처 반환되지 못한 Connection이 계속 
쌓이면 어느 순간에 커넥션 풀에 여유가 없어지고 리소스가 모자란다는 심각한 오류를 내며 서버가 중단될 수 있다.

> JDBC 코드에서는 어떤 상황에서도 가져온 리소스를 반환하도록 try/catch/finally 구문을 사용해야 한다. 예외상황에서도 리소스를 제대로 반환할 수 있어야 한다.
```
public int getCount() throws SQLException {
  Connection c = null;
  PreparedStatement ps = null;
  ResultSet rs = null;
  
  try { // 예외가 발생할 가능성이 있는 코드를 모두 try 블록으로 묶어준다.
    c = dataSource.getConnection();
    
    ps = c.prepareStatement("select count(*) from users");
    
    rs = ps.executeQuery();
    rs.next();
    return rs.getInt(1);
  } catch (SQLException e) { // 예외가 발생했을 때 부가적인 작업을 해줄수 있도록 catch 블록을 둔다.
    throw e;
  } finally { // finally이므로 try 블록에서 예외가 발생했을 때나 안 했을 때나 모두 실행된다.
    if (rs !=null) {
      try {
        rs.close();
      } catch (SQLException e) { // rs.close() 메소드에서도 SQLException이 발생할 수 있다.
      }
    }
    if (ps !=null ) {
      try {
        ps.close();
      } catch (SQLException e) { // ps.close() 메소드에서도 SQLException이 발생할 수 있다.
      }
    }
    if (c != null) {
      try {
        c.close();
      } catch (SQLException e) {
      }
    }
  }
}
```
> close()는 만들어진 순서의 반대로 하는 것이 원칙이다.
<hr/>

### 변하는 것과 변하지 않는 것
#### JDBC try/catch/finally 코드의 문제점
복잡한 try/catch/finally 블록이 2중으로 중첩까지 되어 나오는데다, 모든 메소드마다 반복된다.<br/>
이 문제의 핵심은 변하지 않는, 그러나 많은 곳에서 중복되는 코드와 로직에 따라 자꾸 확장되고 자주 변하는 코드를 잘 분리해내는 작업이다.
#### 분리와 재사용을 위한 디자인 패턴 적용
###### 템플릿 메소드 패턴의 적용
템플릿 메소드 패턴은 상속을 통해 기능을 확장해서 사용하는 부분이다. 변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분은 추상 메소드로 정의해둬서 서브 클래스에서 오버라이드하여 새롭게 정의해 쓰도록 하는 것이다.

추출해서 별도의 메소드로 독립시킨 makeStatement() 메소드를 다음과 같이 추상메소드 선언으로 변경한다.
```
abstract protected PreparedStatement makeStatement(Connection c) throws SQLException;
```
이를 상속하는 서브클래스를 만들어서 거기서 이 메소드를 구현한다. 고정된 JDBC try/catch/finally 블록을 가진 슈퍼클래스 메소드와 필요에 따라서 상속을 통해 구체적인 PreparedStatement를 바꿔서 사용할 수 있게 만드는 서브클래스로 깔끔하게 분리할 수 있다.
```
public class UserDaoDeleteAll extends UserDao {
  protected PreparedStatement makeStatement(Connection c) throws SQLException {
    PreparedStatement ps = c.prepareStatement("delete from users");
    return ps;
  }
}
```
> UserDao 클래스의 기능을 확장하고 싶을 때마다 상속을 통해 자유롭게 확장할 수 있고, 확장 때문에 기존의 상위DAO 클래스에 불필요한 변화는 생기지 않도록 할 수 있으니 객체지향 설계의 핵심 원리인 개방 폐쇄 원칙을 그럭저럭 지키는구조를 만들어낼 수는 있다.

> 하지만 템플릿 메소드 패턴으로의 접근은 제한이 많다. 가장 큰 문제는 DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 한다는 점이다.

> 또 확장구조가 이미 클래스를 설계하는 시점에서 고정되어 버린다는 점이다. 변하지 않는 코드를 가진 UserDao의 JDBC try/catch/finally 블록과 변하는 PreparedStatement를 담고 있는 서브클래스들이 이미 클래스 레벨에서 컴파일 시점에 이미 그 관계가 결정되어 있다. 따라서 그 관계에 대한 유연성이 떨어져 버린다. 

###### 전략 패턴의 적용
개방 폐쇄 원칙을 잘 지키는 구조이면서도 템플릿 메소드 패턴보다 유연하고 확장성이 뛰어난 것이, 오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 전략 패턴이다. 전략 패턴은 OCP 관점에 보면 확장에 해당하는 변하는 부분을 별도의 클래스로 만들어 추상화된 인터페이스를 통해 위임하는 방식이다. 

deleteAll() 메소드에서 변하지 않는 부분이라고 명시한 것이 바로 컨텍스트가 된다. deleteAll()은 JDBC를 이용해 DB를 업데이트하는 작업이라는 변하지 않는 맥락(context)를 갖는다.
* DB 커넥션 가져오기
* PreparedStatement를 만들어줄 외부 기능 호출하기
* 예외가 발생하면 이를 다시 메소드 밖으로 던지기
* 모든 경우에 만들어진 PreparedStatement와 Connectio을 적절히 닫아주기<br/>
> 두 번째 작업에서 사용하는 PreparedStatement를 만들어주는 외부 기응이 바로 전략 패턴에서 말하는 전략이라고 볼 수 있다.

전략 패턴의 구조를 따라 이 기능을 인터페이스로 만들어두고 인터페이스의 메소드를 통해 PreparedStatement 생성 전략을 호출해주면 된다.
```
public interface StatementStrategy {
  PreparedStatement makePreparedStatement(Connection c) throws Exception;
}
```
이 인터페이스를 상속한 실제 전략
```
public class DeleteAllStatement implements StatementStrategy {
  public PreparedStatement make PreparedStatement(Connection c) throws SQLException {
    PreparedStatement ps = c.prepareStatement("delete from users");
    return ps;
  }
}
```
확장된 PreparedStarategy 전략을 context에서 사용하면 된다.
```
public void deleteAll() throws SQLException {
  ...
  try {
    c = dataSource.getConnection();
    
    StatementStrategy strategy = new DeleteAllStatement();
    ps = strategy.makePreparedStatement(c);
    
    ps.executeUpdate();
  } catch (SQLException e) {
    ...
  }
}
```
하지만 전략 패턴은 필요에 따라 컨텍스트는 그대로 유지되면서(OCP의 폐쇄 원칙) 전략은 바꿔 쓸 수  있다(OCP의 개방 원칙)는 것인데, 이렇게 컨텍스트 안에서 이미 구체적인 전략 클래스인 DeleteAllStatement를 사용하도록 고정되어 있다면 뭔가 이상하다. 컨텍스트가 인터페이스뿐아니라 특정 구현 클래스인 DeleteAllStatement를 직접 알고 있다는건, 전략 패턴에도 OCP에도 잘 들어맞는다고 볼 수 없다.

###### DI 적용을 위한 클라이언트/컨텍스트 분리
Client가 구체적인 전략의 하나를 선택하고 오브젝트로 만들어서 Context에 전달해야 한다.Context는 전달받은 그 Strategy 구현 클래스의 오브젝트를 사용한다.<br/>
* 메소드로 분리한 try/catch/finally 컨텍스트 코드
```
public void jdbcContextWithStatementStrategy(StatementStrategy stmt) throws SQLException { // 클라이언트가 컨텍스트를 호출할 때 넘겨줄 전략 파라미터
  Connection c = null;
  PreparedStatement ps = null
  
  try {
    c = dataSource.getConnction();
    
    ps = stme.makePreparedStatement(c);
    
    ps.executeUpdate();
  } catch (SQLExcepton e) {
    throw e;
  } finally {
    if(ps != null) { try { ps.close(); } catch (SQLException e) {} }
    if(c != null) { try { c.close(); } catch (SQLException e) {} }
  }
}
```
* 클라이언트 책임을 담당할 deleteAll() 메소드
```
public void deleteAll() throws SQLException {
  StatementStrategy st = new DeleteAllStatement(); // 선정한 전략 클래스의 오브젝트 생성
  jdbcContextWithStatementStrategy(st); // 컨텍스트 호출, 전략 오브젝트 전달
}
```
<hr/>

### JDBC 전략 패턴의 최적화
현재 만들어진 구조에서는 DAO 메소드마다 새로운 StatementStrategy 구현 클래스를 만들어야 한다. 또, DAO 메소드에서 StatementStrategy에 전달할 User와 같은 부가적인 정보가 있는 경우, 이를 위해 오브젝트를 전달받는 생성자와 이를 저장해둘 인스턴스 변수를 번거롭게 만들어야 한다는 점이다.
###### 로컬 클래스
클래스 파일이 많아지는 문제는 StatementStrategy 전략 클래스를 매번 독립된 파일로 만들지 말고 UserDao 클래스 안에 내부 클래스로 정의해버리는 것이다. 특정 메소드에서만 사용되는 것이라면 로컬 클래스로 만들 수도 있다.
```
public void add(final User user) throws SQLException {
  class AddStatement implements StatementStrategy {
    public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
      PreparedStatement ps = c.preparedStatement(insert into users(id, name, password) values(?,?,?)");
      ps.setString(1, user.getId());
      ps.setString(2, user.getName());
      ps.setString(3, user.getPassword());
      
      return pa;
    }
  }
  
  StatementStrategy st = new AddStatement();
  jdbcContextWithStatementStrategy(st);
}
```
AddStatement 클래스를 로컬 클래스로서 add() 메소드 안에 집어넣었다. 마치 로컬 변수를 선언하듯이 선언하면 된다. 로컬 클래스는 선언된 메소드 내에서만 사용할 수 있다. AddStatement가 사용될 곳이 add() 메소드 뿐이라면, 이렇게 사용하기 전에 바로 정의해서 쓰는 것이다. 덕분에 클래스 파일이 하나 줄었고, add() 메소드 안에서 PreparedStatement 생성 로직을 함께 볼 수 있으니 코드를 이해하기도 좋다. 

로컬 클래스의 다른 장점은 클래스가 내부 클래스이기 때문에 자신이 선언된 곳의 정보에 접근할 수 있다는 것이다. AddStatement는 User 정보를 필요로 한다. 내부 메소드는 자신이 정의된 메소드의 로컬 변수에 직접 접근할 수 있기 때문에 번거롭게 생성자를 통해 User 오브젝트를 전달해줄 필요가 없다. 다만, 내부 클래스에서 외부의 변수를 사용할 때는 외부 변수는 반드시 final로 선언해줘야 한다. user파라미터는 메소드 내부에서 변경될 일이 없으므로 final로 선언해도 무방하다.

###### 익명 내부 클래스
AddStatement 클래스는 add() 메소드에서만 사용할 용도로 만들어졌으니 좀 더 간결하게 이름도 제거할 수 있다. 익명 내부 클래스는 선언과 동시에 오브젝트를 생성한다. 이름이 없기 때문에 클래스 자신의 타입을 가질 수 없고, 구현한 인터페이스 타입의 변수에만 저장할 수 있다.

만들어진 익명 내부 클래스의 오브젝트는 딱 한 번만 사용할 테니 굳이 변수에 담아 두지 말고 jdbcContextWithStatementStrategy() 메소드의 파라미터에서 바로 생성하는 편이 낫다.
```
public void add(final User user) throws SQLException {
  jdbcContextWithStatementStrategy (
    new StatementStrategy() {
      public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
        PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?,?,?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());
        
        return ps;
      }
    }
  );
}
```
* 중첩 클래스의 종류
    * 다른 클래스 내부에 정의되는 클래스를 중첩 클래스라고 한다. 중첩 클래스는 독립적으로 오브젝트로 만들어질 수 있는 스태틱 클래스와 자신이 정의된 클래스의 오브젝트 안에서만 만들어질 수 있는 내부 클래스로 구분된다.
        * 내부 클래스는 다시 범위에 따라 세 가지로 구분된다. 멤버 필드처럼 오브젝트 레벨에 정의되는 멤버 내부 클래스와 메소드 레벨에 정의되는 로컬 클래스, 그리고 이름을 갖지 않는 익명 내부 클래스다. 익명 내부클래스의 범위는 선언된 위치에 따라서 다르다.
* 익명 내부 클래스
    * 익명 내부클래스는 이름을 갖지 않는 클래스다. 클래스 선언과 오브젝트 생성이 결합된 형태로 만들어지며, 상속할 클래스나 구현할 인터페이스를 생성자 대신 사용해서 다음과 같은 형태로 만들어 사용한다. 클래스를 재사용할 필요가 없고, 구현한 인터페이스 타입으로만 사용할 경우에 유용하다.
        * new 인터페이스 이름() { 클래스 본문 };
        
    
